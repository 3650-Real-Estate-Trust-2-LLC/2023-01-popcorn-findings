# Permit signatures are malleable

ECDSA signatures are bounded to points of the curve generated by low range s-values. The permit function allows any `s` value as valid, without taking into account the elliptic property of the curves. 
As a result, signed permits could have two different valid points of the curve meaning that the signature is malleable:

```solidity
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);

        // Unchecked because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            address recoveredAddress = ecrecover(
                keccak256(
                    abi.encodePacked(
                        "\x19\x01",
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                keccak256(
                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
                                ),
                                owner,
                                spender,
                                value,
                                nonces[owner]++,
                                deadline
                            )
                        )
                    )
                ),
                v,
                r,
                s
            );

            if (recoveredAddress == address(0) || recoveredAddress != owner)
                revert InvalidSigner(recoveredAddress);

            _approve(recoveredAddress, spender, value);
        }
    }
```
There are no checks that ensure lower range `s` values accepting any, meaning tha two different points of the curve can derive in the same signature. 

## Mitigation

OpenZeppelin ensures under [ECDSA.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3b591a48acaab78008ed39d60fbcf429a83155ca/contracts/utils/cryptography/ECDSA.sol#L124) that only lower range `s` values are valid:

```solidity
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
```

If no foreign ECDSA library is meant to be used, add the check mentioned above.

